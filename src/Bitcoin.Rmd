---
title: "Time Series Analysis final Project - Competitive "
author: "Team Members: 1.Rahul k. gupta (sxxxxxxx) 2.Terrie christensen (sxxxxxxx) 3.Napapach Dechawatthanaphokin (s3613572)"
date: "14 May 2018"
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: no
    toc_depth: 3
  html_document:
    df_print: paged
    toc: no
    toc_depth: '3'
  word_document:
    toc: no
    toc_depth: '3'
linkcolor: blue
references:
- author:
  - family: Xie
    given: YiHui
    issued:
    - year: 2018
    publisher: Chapman and Hall/CRC
    title: Dynamic Documents with R and knitr
  id: knitr
subtitle: MATH 1318 Time Series Analysis Final Project
documentclass: article
---

\newpage

\tableofcontents

\newpage

# Introduction \label{sec1}

Bitcoin or BTC is a digital currency, otherwise known as a cryptocurrency. it was introduced to markets in 2009 by 'Satoshi Nakamoto.' The most notable aspect of BTC is that no banks or financial institutions are needed to facilitate trades. Additionally, it runs as a virtually anonymous financial system whereby buyers and sellers do not need to input their names, addresses or any other personally identifiable information to transfer BTC.

Rahul Made these changes

# Model Diagnosis

```{r ,fig.width=8,fig.height=5,warning=FALSE,message=FALSE}
# Import Libraries
library(TSA)
library(fUnitRoots)
library(forecast)
library(CombMSC)
library(lmtest)
library(fGarch)
library(rugarch)
library(zoo)
library(ggplot2)
```


```{r ,fig.width=8,fig.height=5,warning=FALSE,message=FALSE,echo=FALSE}
# Require sort.score when knit to pdf, html
sort.score <- function(x, score = c("bic", "aic")){
  if (score == "aic"){
    x[with(x, order(AIC)),]
  } else if (score == "bic") {
    x[with(x, order(BIC)),]
  } else {
    warning('score = "x" only accepts valid arguments ("aic","bic")')
  }
}
```


```{r}
residual.analysis <- function(model, std = TRUE){
  library(TSA)
  library(FitAR)
  if (std == TRUE){
    res.model = rstandard(model)
  }else{
    res.model = residuals(model)
  }
  par(mfrow=c(3,2))
  plot(res.model,type='o',ylab='Standardised residuals', main="Time series plot of standardised residuals")
  abline(h=0)
  hist(res.model,main="Histogram of standardised residuals")
  qqnorm(res.model,main="QQ plot of standardised residuals")
  qqline(res.model, col = 2)
  acf(res.model,main="ACF of standardised residuals")
  print(shapiro.test(res.model))
  k=0
  LBQPlot(res.model, lag.max = length(model$residuals)-1 , StartLag = k + 1, k = 0, SquaredQ = FALSE)
  par(mfrow=c(1,1))
}
```


```{r}
Bitcoin <- read.csv("../Bitcoin_Historical_Price.csv", header=TRUE)
Bitcoin$Date = as.Date(Bitcoin$Date,'%Y-%m-%d')
```



```{r}
Bitcoin.zoo <- zoo(Bitcoin$Close, Bitcoin$Date)
class(Bitcoin.zoo)
Bitcoin.raw = Bitcoin.zoo
```


```{r}
autoplot.zoo(Bitcoin.zoo) +
  ylab('Closing Price (USD)') + 
  xlab('Time (days)') +
  ggtitle("Time Series Plot for Daily Bitcoin Prices")
```


```{r}

Bitcoin.2017 = Bitcoin[Bitcoin$Date > as.Date("2017-04-01"),]
Bitcoin.2017.zoo = zoo(Bitcoin.2017$Close, Bitcoin.2017$Date)
autoplot(Bitcoin.2017.zoo) +
  geom_point(size=.5) +
  ylab('Closing Price (USD)') + 
  xlab('Time (days)') +
  ggtitle("Time Series Plot for Daily Bitcoin Prices (2017-2018)")
```

## Scatter Plot and correlation

```{r}
ggplot(Bitcoin.2017,aes(zlag(Close), Close)) + geom_point() +
  ylab('Current Closing Price (USD)') + 
  xlab('Previous Day Closing Price (USD)') +
  ggtitle("Scatter Plot of Bitcoin Daily Closing Prices")
```


```{r}
y = as.vector(Bitcoin.2017.zoo)
x = zlag(Bitcoin.2017.zoo)     
index = 2:length(x)      
cor(y[index],x[index])
```

## Linear Model

```{r}
model.ln = lm(Bitcoin.2017.zoo~time(Bitcoin.2017.zoo)) # label the linear trend model as model.ln
summary(model.ln)
```

```{r}
ggplot(Bitcoin.2017,aes(Date,Close))+ 
  geom_line()  +
  ylab('Closing Price (USD)') + 
  xlab('') +
  ggtitle('Linear Fitted Model - Bitcoin Prices') +
  geom_line(aes(y=fitted(model.ln)),color='#fc5e13')
```


## Residual Analysis - Linear Model

Below are the findings of residuals from linear model

\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin}Residual Analysis Linear fitted Model")}
residual_analysis_qq <- function(myresiduals) {
data=as.data.frame(qqnorm( myresiduals , plot=F))
ggplot(data,aes(x,y)) + 
  geom_point() + 
  geom_smooth(method="lm", se=FALSE, color='#e36209', size=.4)+
  xlab('Theoretical') +
  ylab('Sample') +
  ggtitle('QQ Plot of Residuals')
}

checkresiduals(model.ln)
```


\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin_qq}Residual Analysis Linear fitted Model")}
residual_analysis_qq(residuals(model.ln))
```

\vspace{12pt}

```{r}
shapiro.test(as.vector(residuals(model.ln)))
```

## Quadratic Model

```{r}
t = as.vector(time(Bitcoin.2017.zoo))
t2 = t^2
model.qa = lm(Bitcoin.2017.zoo~ t + t2) # label the quadratic trend model as model.qa
summary(model.qa)

ggplot(Bitcoin.2017,aes(Date,Close))+ 
  geom_line()  +
  ylab('Closing Price (USD)') + 
  xlab('') +
  ggtitle('Quadratic fitted Model Curve - Bitcoin Daily Prices') +
  geom_line(aes(y=fitted(model.qa)),color='#fc5e13')
```


## Residual Analysis - Linear Model

Below are the findings of residuals from linear model

\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin}Residual Analysis Quadratic fitted Model")}
checkresiduals(model.qa)
```


\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin_qq}Residual Analysis Linear fitted Model")}
residual_analysis_qq(residuals(model.qa))
```

\vspace{12pt}

```{r}
shapiro.test(as.vector(residuals(model.qa)))
```

# Models for Nonstationary Time Series

Auto regressive behaviour and non staionay
Staionay is the first thing we need to check.

```{r}
ggtsdisplay(Bitcoin.2017.zoo,
            main = 'ACF and PACF of Bitcoin Prices', 
            ylab='Closing Price (USD)')
```


stategy to make stationay is transfromation.

```{r}
Bitcoin.transform = BoxCox.ar(Bitcoin.2017.zoo, method = 'yule-walker') 
```

```{r}
lambda = sum(Bitcoin.transform$ci)/length(Bitcoin.transform$ci)
Bitcoin.boxcox = (Bitcoin.2017.zoo^lambda - 1) / lambda 
Bitcoin.diff = base::diff(Bitcoin.boxcox, differences = 1)
autoplot(Bitcoin.diff) +
  ylab('Closing Price (USD)') + 
  ggtitle('Boxcox Transformed & First Differenced Series')
```

```{r}
ggtsdisplay(Bitcoin.diff, lag.max = 96,
            main = 'Boxcox Transformed & First Differenced ACF and PACF plots', 
            ylab='')
```

```{r}
adf.test(Bitcoin.diff)
```


```{r}
eacf(Bitcoin.diff)
# ARIMA(0,1,0),ARIMA(1,1,1),ARIMA(2,1,2),ARIMA(4,1,3)
```

```{r}
res1 = armasubsets(y=Bitcoin.diff,nar=12,nma=12,y.name='test',ar.method='ols')
plot(res1)
#ARIMA(4,1,4),ARIMA(5,1,4)
```




```{r}
#The final set of possible models is 
# ARIMA(0,1,0),ARIMA(1,1,1),ARIMA(2,1,2),ARIMA(4,1,3)
# ARIMA(4,1,4),ARIMA(5,1,4)

# ARIMA(0,1,0)
model_111_css = arima(Bitcoin.boxcox, order=c(1,1,1),method='CSS')
coeftest(model_111_css)

model_111_ml = arima(Bitcoin.boxcox, order=c(1,1,1),method='ML')
coeftest(model_111_ml)

# ARIMA(2,1,2)
model_212_css = arima(Bitcoin.boxcox,order=c(2,1,2),method='CSS')
coeftest(model_212_css)

model_212_ml = arima(Bitcoin.boxcox,order=c(2,1,2),method='ML')
coeftest(model_212_ml)

# ARIMA(4,1,3)
model_413_css = arima(Bitcoin.boxcox,order=c(4,1,3),method='CSS')
coeftest(model_413_css)

model_413_ml = arima(Bitcoin.boxcox,order=c(4,1,3),method='ML')
coeftest(model_413_ml)

# ARIMA(4,1,4)
model_414_css = arima(Bitcoin.boxcox,order=c(4,1,4),method='CSS')
coeftest(model_414_css)

model_414_ml = arima(Bitcoin.boxcox,order=c(4,1,4),method='ML')
coeftest(model_414_ml)

# ARIMA(5,1,4)
model_514_css = arima(Bitcoin.boxcox,order=c(5,1,4),method='CSS')
coeftest(model_514_css)

model_514_ml = arima(Bitcoin.boxcox,order=c(5,1,4),method='ML')
coeftest(model_514_ml)

```

```{r}
sort.score(AIC(model_111_ml,model_212_ml,model_413_ml,model_414_ml,model_514_ml), score = "aic")
sort.score(BIC(model_111_ml,model_212_ml,model_413_ml,model_414_ml,model_514_ml), score = "bic" )
```

```{r,fig.width=8,fig.height=5,warning=FALSE,message=FALSE,echo=FALSE}
residual.analysis(model = model_021_ml)
par(mfrow=c(1,1))
# There is no problem with the diagnostic plots.

# We applied log transformtion and second difference. To take them back:
log.data = log(Bitcoin.raw)
log.data.diff2.back = diffinv(diff.log.Bitcoin2, differences = 2, xi = data.matrix(log.data[1:2]))
log.data.diff2.back = exp(log.data.diff2.back)
```


```{r}
library(forecast)
fit = Arima(Bitcoin.raw,c(0,2,1)) 
plot(forecast(fit,h=10))
```

```{r}
McLeod.Li.test(y=diff.log.Bitcoin2,main="McLeod-Li Test Statistics for Daily Google Returns")
# McLeod-Li test is significnat at 5% level of significance for all lags. This gives a strong idea about existence of volatiliy clustering.
qqnorm(diff.log.Bitcoin2,main="Q-Q Normal Plot of Daily Google Returns")
qqline(diff.log.Bitcoin2) # Fat tails is in accordance with volatiliy clustering
```

```{r}
par(mfrow=c(1,2))
acf(diff.log.Bitcoin2, main="The sample ACF plot for return series")
pacf(diff.log.Bitcoin2, main="The sample PACF plot for return series")
eacf(diff.log.Bitcoin2)
```

```{r}
abs.diff.log.Bitcoin2 = abs(diff.log.Bitcoin2)
sq.diff.log.Bitcoin2 = diff.log.Bitcoin2^2
```


```{r}
par(mfrow=c(1,2))
acf(abs.diff.log.Bitcoin2, ci.type="ma",main="The sample ACF plot for absolute return series")
pacf(abs.diff.log.Bitcoin2, main="The sample PACF plot for absolute return series")
eacf(abs.diff.log.Bitcoin2)
```


```{r}
par(mfrow=c(1,2))
acf(sq.diff.log.Bitcoin2, ci.type="ma",main="The sample ACF plot for squared return series")
pacf(sq.diff.log.Bitcoin2, main="The sample PACF plot for squared return series")
eacf(sq.diff.log.Bitcoin2)
```

```{r}
m.11 = garch(diff.log.Bitcoin2,order=c(1,1),trace = FALSE)
summary(m.11) # All the coefficients are significant at 5% level of significance.
m.11_2 = garchFit(formula = ~garch(1,1), data =diff.log.Bitcoin2 )
summary(m.11_2)
```

