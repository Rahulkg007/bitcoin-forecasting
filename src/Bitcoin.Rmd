---
title: "Time Series Analysis final Project - Competitive "
author: "Team Members: 1.Rahul k. gupta (s3635232) 2.Terrie christensen (s3664899) 3.Napapach Dechawatthanaphokin (s3613572)"
date: "14 May 2018"
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: no
    toc_depth: 3
    includes:
      in_header: preamble-latex.tex
subtitle: MATH 1318 Time Series Analysis Final Project
documentclass: article
---


```{r global_options, include=FALSE, warning=FALSE}
require(knitr)
opts_chunk$set(warning=FALSE, message=FALSE)
```


\newpage

\tableofcontents

\newpage

# Introduction \label{sec1}

Bitcoin is a type of cryptocurrency, i.e. it is a digital currency which uses encryption techniques to generate units of the currency and verify the transfer of funds. Bitcoin is a decentralised currency, which operates independently of a central bank. An estimated 2.9 to 5.8 million unique users have a *cryptocurrency wallet*, of which most use bitcoin. The price of bitcoin has gone through various cycles of appreciation and depreciation, known as bubbles and bursts, with price fluctuations up to a magnitude of a few thousand USD in the space of a day, so that the currency has become renown for its volatility. The bitcoin historical price data gathered from the CoinMarketCap.
This time series will be modelled using regression, ARIMA and GARCH methods. The report details;

* Description of the time series 

* Model specification 

* Model fitting and selection 

* Diagnostic checking

* Predict the value of bitcoin for the following 10 days 


# Initial Diagnosis

```{r}
# Import Libraries
library(TSA)
library(fUnitRoots)
library(forecast)
library(CombMSC)
library(lmtest)
library(fGarch)
library(rugarch)
library(zoo)
library(ggplot2)
require(readr)
require(FitAR)

Bitcoin <- read.csv("../data/Bitcoin_Historical_Price.csv", header=TRUE)
Bitcoin$Date = as.Date(Bitcoin$Date,'%Y-%m-%d')
Bitcoin.zoo <- zoo(Bitcoin$Close, Bitcoin$Date)
Bitcoin.raw = Bitcoin.zoo
```

\vspace{12pt}

Data is converted to time series object using zoo library. Figure \ref{fig:bitcoin_orig} shows the daily closing price of bitcoin from the 27th Apr 2013 to the 3rd Mar 2018, given in USD. 


\vspace{12pt}

```{r fig.cap=paste("\\label{fig:bitcoin_orig}Time Series of Daily Bitcoin Prices")}
autoplot.zoo(Bitcoin.zoo) +
  ylab('Closing Price (USD)') + 
  xlab('Time (days)') +
  ggtitle("Time Series Plot for Daily Bitcoin Prices")
```

\vspace{12pt}

Figure \ref{fig:bitcoin_subset} shows time series of last one year

\vspace{12pt}

```{r fig.cap=paste("\\label{fig:bitcoin_subset}Subset Time Series of Daily Bitcoin Prices")}
Bitcoin.2017 = Bitcoin[Bitcoin$Date > as.Date("2017-04-01"),]
Bitcoin.2017.zoo = zoo(Bitcoin.2017$Close, Bitcoin.2017$Date)
autoplot(Bitcoin.2017.zoo) +
  geom_point(size=.5) +
  ylab('Closing Price (USD)') + 
  xlab('Time (days)') +
  ggtitle("Time Series Plot for Daily Bitcoin Prices (2017-2018)")
```

## Scatter Plot and correlation

```{r}
ggplot(Bitcoin.2017,aes(zlag(Close), Close)) + geom_point() +
  ylab('Current Closing Price (USD)') + 
  xlab('Previous Day Closing Price (USD)') +
  ggtitle("Scatter Plot of Bitcoin Daily Closing Prices")
```


```{r}
y = as.vector(Bitcoin.2017.zoo)
x = zlag(Bitcoin.2017.zoo)     
index = 2:length(x)      
cor(y[index],x[index])
```

## Linear Model

```{r}
model.ln = lm(Bitcoin.2017.zoo~time(Bitcoin.2017.zoo)) # label the linear trend model as model.ln
summary(model.ln)
```

```{r}
ggplot(Bitcoin.2017,aes(Date,Close))+ 
  geom_line()  +
  ylab('Closing Price (USD)') + 
  xlab('') +
  ggtitle('Linear Fitted Model - Bitcoin Prices') +
  geom_line(aes(y=fitted(model.ln)),color='#fc5e13')
```


## Residual Analysis - Linear Model

Below are the findings of residuals from linear model

\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin}Residual Analysis Linear fitted Model")}
residual_analysis_qq <- function(myresiduals, title = 'QQ Plot of Residuals') {
data=as.data.frame(qqnorm( myresiduals , plot=F))
ggplot(data,aes(x,y)) + 
  geom_point() + 
  geom_smooth(method="lm", se=FALSE, color='#e36209', size=.4)+
  xlab('Theoretical') +
  ylab('Sample') +
  ggtitle(title)
}

checkresiduals(model.ln)
```


\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin_qq}Residual Analysis Linear fitted Model")}
residual_analysis_qq(residuals(model.ln))
```

\vspace{12pt}

```{r}
shapiro.test(as.vector(residuals(model.ln)))
```

## Quadratic Model

```{r}
t = as.vector(time(Bitcoin.2017.zoo))
t2 = t^2
model.qa = lm(Bitcoin.2017.zoo~ t + t2) # label the quadratic trend model as model.qa
summary(model.qa)

ggplot(Bitcoin.2017,aes(Date,Close))+ 
  geom_line()  +
  ylab('Closing Price (USD)') + 
  xlab('') +
  ggtitle('Quadratic fitted Model Curve - Bitcoin Daily Prices') +
  geom_line(aes(y=fitted(model.qa)),color='#fc5e13')
```


## Residual Analysis - Linear Model

Below are the findings of residuals from linear model

\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin}Residual Analysis Quadratic fitted Model")}
checkresiduals(model.qa)
```


\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin_qq}Residual Analysis Linear fitted Model")}
residual_analysis_qq(residuals(model.qa))
```

\vspace{12pt}

```{r}
shapiro.test(as.vector(residuals(model.qa)))
```

# Models for Nonstationary Time Series

Auto regressive behaviour and non staionay
Staionay is the first thing we need to check.

```{r}
ggtsdisplay(Bitcoin.2017.zoo,
            main = 'ACF and PACF of Bitcoin Prices', 
            ylab='Closing Price (USD)')
```


stategy to make stationay is transfromation.

```{r}
Bitcoin.transform = BoxCox.ar(Bitcoin.2017.zoo, method = 'yule-walker') 
```

```{r}
lambda = sum(Bitcoin.transform$ci)/length(Bitcoin.transform$ci)
Bitcoin.boxcox = (Bitcoin.2017.zoo^lambda - 1) / lambda 
Bitcoin.diff = base::diff(Bitcoin.boxcox, differences = 1)
autoplot(Bitcoin.diff) +
  ylab('Closing Price (USD)') + 
  ggtitle('Boxcox Transformed & First Differenced Series')
```

```{r}
ggtsdisplay(Bitcoin.diff, lag.max = 96,ci.type='ma',
            main = 'Boxcox Transformed & First Differenced ACF and PACF plots', 
            ylab='')
```

```{r}
adf.test(Bitcoin.diff)
```


```{r}
eacf(Bitcoin.diff)
# ARIMA(0,1,0),ARIMA(1,1,1),ARIMA(2,1,2),ARIMA(4,1,3)
```

```{r}
res1 = armasubsets(y=Bitcoin.diff,nar=14,nma=14,y.name='test',ar.method='mle')
plot(res1)
#ARIMA(4,1,4),ARIMA(5,1,4)
```



```{r}
#The final set of possible models is 
# ARIMA(0,1,0),ARIMA(1,1,1),ARIMA(2,1,2),ARIMA(4,1,3)
# ARIMA(4,1,4),ARIMA(5,1,4)

# ARIMA(1,1,1)
model_111_css = arima(Bitcoin.boxcox, order=c(1,1,1),method='CSS')
coeftest(model_111_css)

model_111_ml = arima(Bitcoin.boxcox, order=c(1,1,1),method='ML')
coeftest(model_111_ml)

```

```{r}
# ARIMA(1,1,2)
model_112_css = arima(Bitcoin.boxcox,order=c(1,1,2),method='CSS')
coeftest(model_112_css)

model_112_ml = arima(Bitcoin.boxcox,order=c(1,1,2),method='ML')
coeftest(model_112_ml)
```

```{r}
# ARIMA(2,1,1)
model_211_css = arima(Bitcoin.boxcox,order=c(2,1,1),method='CSS')
coeftest(model_211_css)

model_211_ml = arima(Bitcoin.boxcox,order=c(2,1,1),method='ML')
coeftest(model_211_ml)
```

```{r}
# ARIMA(2,1,2)
model_212_css = arima(Bitcoin.boxcox,order=c(2,1,2),method='CSS')
coeftest(model_212_css)

model_212_ml = arima(Bitcoin.boxcox,order=c(2,1,2),method='ML')
coeftest(model_212_ml)
```

```{r}
# ARIMA(3,1,2)
model_312_css = arima(Bitcoin.boxcox,order=c(3,1,2),method='CSS')
coeftest(model_312_css)

model_312_ml = arima(Bitcoin.boxcox,order=c(3,1,2),method='ML')
coeftest(model_312_ml)
```


```{r}
# ARIMA(4,1,2)
model_412_css = arima(Bitcoin.boxcox,order=c(4,1,2),method='CSS')
coeftest(model_412_css)

model_412_ml = arima(Bitcoin.boxcox,order=c(4,1,2),method='ML')
coeftest(model_412_ml)
```

```{r}

# ARIMA(4,1,4)
model_414_css = arima(Bitcoin.boxcox,order=c(4,1,4),method='CSS')
coeftest(model_414_css)

model_414_ml = arima(Bitcoin.boxcox,order=c(4,1,4),method='ML')
coeftest(model_414_ml)
```

```{r}
# ARIMA(5,1,4)
model_514_css = arima(Bitcoin.boxcox,order=c(5,1,4),method='CSS')
coeftest(model_514_css)

model_514_ml = arima(Bitcoin.boxcox,order=c(5,1,4),method='ML')
coeftest(model_514_ml)

```


```{r}
source('sort.score.r')
sort.score(stats::AIC(model_111_ml,model_112_ml,model_211_ml,model_212_ml,model_312_ml,model_412_ml,model_414_ml,model_514_ml), score = "aic")
sort.score(stats::BIC(model_111_ml,model_112_ml,model_211_ml,model_212_ml,model_312_ml,model_412_ml,model_414_ml,model_514_ml), score = "bic" )
```


\vspace{12pt}

```{r}
fit <- Arima(Bitcoin.2017.zoo, order=c(3,1,2), lambda = lambda)
summary(fit)
```

## Residual Analysis - ARIMA Model

Below are the findings of residuals from linear model

\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin}Residual Analysis Quadratic fitted Model")}
checkresiduals(fit)
```


\vspace{12pt}

```{r fig.cap=paste("\\label{fig:res_lin_qq}Residual Analysis Linear fitted Model")}
residual_analysis_qq(residuals(fit))
```

\vspace{12pt}

```{r}
shapiro.test(as.vector(residuals(fit)))
```

\vspace{12pt}

```{r}
x = residuals(fit)
k=0
LBQPlot(x, lag.max = length(x)-1 , StartLag = k + 1, k = 0, SquaredQ = FALSE)
grid()
```


## Forecast 

```{r}
autoplot(forecast(fit,h=10))
```

```{r}
Bitcoin.forecast <- read_csv("../data/Bitcoin_Prices_Forecasts.csv")
Bitcoin.forecast$Date = as.Date(Bitcoin.forecast$Date,'%d/%m/%y')
```

## MASE Error

```{r}
source('MASE.r')
MASE(Bitcoin.forecast$`Closing price`,
     as.vector(tail(fitted(forecast(fit,h=10)),10)))
```



```{r}
McLeod.Li.test(y=Bitcoin.2017.zoo,main="McLeod-Li Test Statistics for Bitcoin")

residual_analysis_qq(Bitcoin.2017.zoo, 'QQ Plot')
```

# Heteroscedasticity Models

```{r}
McLeod.Li.test(y=Bitcoin.2017.zoo,main="McLeod-Li Test Statistics for Daily Google Returns")
```

McLeod-Li test is significnat at 5% level of significance for all lags. This gives a strong idea about existence of volatiliy clustering.


```{r}
#So we'll use absolute value and square transformations to figure out this ARCH effect.
abs.bitcoin = abs(Bitcoin.2017.zoo)
sq.bitcoin = Bitcoin.2017.zoo^2

par(mfrow=c(1,2))
acf(abs.bitcoin, ci.type="ma",main="The sample ACF plot for absolute return series")
pacf(abs.bitcoin, main="The sample PACF plot for absolute return series")
```


```{r}
eacf(abs.bitcoin)
```
# After the absolute value transformation, we boserve many signficicant lags in 
#both ACF and PACF. Also, EACF do not suggest an ARMA(0,0) model.
# From the EACF, we can identify ARMA(1,0), ARMA(1,1), and ARMA(2,1) models for absolute 
#value series. 
# These models correspond to parameter settings of [max(1,1),1], [max(1,2),1] and [max(2,2),2]. 
# So the corresponding tentative GARCH models are GARCH(0,1), GARCH(1,1), GARCH(1,2).

```{r}
par(mfrow=c(1,2))
acf(sq.bitcoin, ci.type="ma",main="The sample ACF plot for squared return series")
pacf(sq.bitcoin, main="The sample PACF plot for squared return series")
```

```{r}
eacf(sq.bitcoin)
```
# After the square transformation, we boserve many signficicant lags in both ACF and PACF. Also, EACF do not suggest an ARMA(0,0) model.
# From the EACF, we can identify ARMA(1,1), ARMA(1,2), and ARMA(2,2) models for squared series. 
# These models correspond to parameter settings of [max(1,1),1], [max(1,2),1], [max(1,2),2], and [max(2,2),2]. So the corresponding 
# tentative GARCH models are GARCH(1,1), GARCH(2,1), GARCH(2,2).

```{r}
m.11 = garch(Bitcoin.2017.zoo,order=c(1,1),trace = FALSE)
summary(m.11) # All the coefficients are significant at 5% level of significance.
m.11_2 = garchFit(formula = ~garch(1,1), data =Bitcoin.2017.zoo )
summary(m.11_2)

m.12 = garch(Bitcoin.2017.zoo,order=c(1,2),trace = FALSE)
summary(m.12)# All the coefficients but aplha_2 are significant at 5% level of significance.
m.12_2 = garchFit(formula = ~garch(2,1), data =Bitcoin.2017.zoo, trace = FALSE )
summary(m.12_2)

m.22 = garch(Bitcoin.2017.zoo,order=c(2,2),trace = FALSE)
summary(m.22) # Higher order parameters are insignificant
m.22_2 = garchFit(formula = ~garch(2,2), data =Bitcoin.2017.zoo, trace = FALSE, cond.dist = "QMLE" )
summary(m.22_2)

```

